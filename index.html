<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Swipe Speed Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <style>
    html, body { margin:0; height:100%; background:#111; overflow:hidden; }
    #hud {
      position: fixed; top: 10px; left: 10px; right: 10px;
      color: #0ff; font: 16px/1.4 system-ui, sans-serif;
      text-shadow: 0 0 8px #0ff;
    }
    canvas {
      display:block; width:100vw; height:100vh;
      touch-action: none; /* capture gestures on canvas */
    }
    .label { color:#aaa; }
  </style>
</head>
<body>
<div id="hud">
  <div><span class="label">Instruction:</span> Swipe RIGHT to increase speed, LEFT to decrease.</div>
  <div><span class="label">Speed:</span> <span id="speedVal">0</span></div>
</div>
<canvas id="c"></canvas>

<script>
(function(){
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const speedEl = document.getElementById('speedVal');

  // HiDPI setup
  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = Math.floor(window.innerWidth);
    const h = Math.floor(window.innerHeight);
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // State
  let speed = 0;          // current speed
  let targetSpeed = 0;    // controlled by swipe
  let lastX = null;       // for delta detection
  let dots = [];
  const DOTS = 60;

  // Create rows of dots to visualize speed
  function initDots() {
    dots = [];
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    for (let i = 0; i < DOTS; i++) {
      dots.push({
        x: Math.random() * w,
        y: (i / DOTS) * h,
        size: 3 + Math.random() * 2
      });
    }
  }
  initDots();

  // Draw loop
  function loop() {
    // smooth speed changes
    speed += (targetSpeed - speed) * 0.12;

    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);

    // background
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, w, h);

    // move and draw dots (move faster with speed)
    for (const d of dots) {
      d.x += speed;
      if (d.x > w + 10) d.x = -10;
      if (d.x < -10) d.x = w + 10;
      ctx.fillStyle = '#0ff';
      ctx.fillRect(d.x, d.y, d.size, d.size);
    }

    // HUD update
    speedEl.textContent = targetSpeed.toFixed(1);

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Pointer events (work for touch + mouse)
  function onPointerDown(e) {
    lastX = e.clientX;
    canvas.setPointerCapture(e.pointerId);
    e.preventDefault();
  }
  function onPointerMove(e) {
    if (lastX == null) return;
    const dx = e.clientX - lastX;
    // Right increases, left decreases
    if (Math.abs(dx) > 1) {
      targetSpeed = clamp(targetSpeed + (dx > 0 ? 1.5 : -1.5), -30, 30);
      lastX = e.clientX;
    }
    e.preventDefault();
  }
  function onPointerUp(e) {
    lastX = null;
    try { canvas.releasePointerCapture(e.pointerId); } catch {}
    e.preventDefault();
  }

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
  canvas.addEventListener('pointermove', onPointerMove, { passive: false });
  canvas.addEventListener('pointerup', onPointerUp, { passive: false });
  canvas.addEventListener('pointercancel', onPointerUp, { passive: false });

  // Extra guard to prevent scrolling if canvas is touched
  ['touchstart','touchmove','touchend','touchcancel'].forEach(type => {
    document.addEventListener(type, (e) => {
      if (e.target === canvas) e.preventDefault();
    }, { passive: false });
  });
})();
</script>
</body>
</html>
